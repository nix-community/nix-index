/// Creating and searching file databases.
///
/// This module implements an abstraction for creating an index of files with meta information
/// and searching that index for paths matching a specific pattern.
use std::io::{self, Read, Write, BufWriter, BufReader, Seek, SeekFrom};
use std::fs::File;
use std::path::Path;
use zstd;
use grep::{Grep, Match, GrepBuilder};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use serde_json;

use package::StorePath;
use files::{FileTree, FileTreeEntry};
use frcode;

/// The version of the database format supported by this nix-index version.
///
/// This should be updated whenever you make an incompatible change to the database format.
const FORMAT_VERSION: u64 = 1;

/// The magic for nix-index database files, used to ensure that the file we're passed is
/// actually a file generated by nix-index.
const FILE_MAGIC: &'static [u8] = b"NIXI";


/// A writer for creating a new file database.
pub struct Writer {
    /// The encoder used to compress the database. Will be set to `None` when the value
    /// is dropped.
    writer: Option<BufWriter<zstd::Encoder<File>>>,
}

// We need to make sure that the encoder is `finish`ed in all cases, so we need
// a custom Drop.
impl Drop for Writer {
    fn drop(&mut self) {
        if self.writer.is_some() {
            self.finish_encoder().unwrap();
        }
    }
}

impl Writer {
    /// Creates a new database at the given path with the specified zstd compression level
    /// (currently, supported values range from 0 to 22).
    pub fn create<P: AsRef<Path>>(path: P, level: i32) -> io::Result<Writer> {
        let mut file = File::create(path)?;
        file.write_all(FILE_MAGIC)?;
        file.write_u64::<LittleEndian>(FORMAT_VERSION)?;
        let encoder = zstd::Encoder::new(file, level)?;

        Ok(Writer { writer: Some(BufWriter::new(encoder)) })
    }

    /// Add a new package to the database for the given store path with its corresponding
    /// file tree.
    pub fn add(&mut self, path: StorePath, files: FileTree) -> io::Result<()> {
        let writer = self.writer.as_mut().expect("not dropped yet");
        let mut encoder =
            frcode::Encoder::new(writer, b"p".to_vec(), serde_json::to_vec(&path).unwrap());
        for entry in files.to_list() {
            entry.encode(&mut encoder)?;
        }
        Ok(())
    }

    /// Finishes encoding. After calling this function, `add` may no longer be called, since this function
    /// closes the stream.
    ///
    /// The return value is the underlying File.
    fn finish_encoder(&mut self) -> io::Result<File> {
        let writer = self.writer.take().expect("not dropped yet");
        let encoder = writer.into_inner()?;
        encoder.finish()
    }

    /// Finish the encoding and return the size in bytes of the compressed file that was created.
    pub fn finish(mut self) -> io::Result<u64> {
        let mut file = self.finish_encoder()?;
        file.seek(SeekFrom::Current(0))
    }
}

error_chain! {
    errors {
        UnsupportedFileType(found: Vec<u8>) {
            description("unsupported file type")
            display("expected file to start with nix-index file magic 'NIXI', but found '{}' (is this a valid nix-index database file?)", String::from_utf8_lossy(found))
        }
        UnsupportedVersion(found: u64) {
            description("unsupported file version")
            display("this executable only supports the nix-index database version {}, but found a database with version {}", FORMAT_VERSION, found)
        }
        MissingPackageEntry {
            description("missing package entry for path")
            display("database corrupt, found a file entry without a matching package entry")
        }
        Frcode(err: frcode::Error) {
            description("frcode error")
            display("database corrupt, frcode error: {}", err)
        }
        EntryParse(entry: Vec<u8>) {
            description("entry parse failure")
            display("database corrupt, could not parse entry: {:?}", String::from_utf8_lossy(entry))
        }
        StorePathParse(path: Vec<u8>) {
            description("store path parse failure")
            display("database corrupt, could not parse store path: {:?}", String::from_utf8_lossy(path))
        }
    }

    foreign_links {
        Io(io::Error);
    }
}

impl From<frcode::Error> for Error {
    fn from(err: frcode::Error) -> Error {
        ErrorKind::Frcode(err).into()
    }
}

/// A Reader allows fast querying of a nix-index database.
pub struct Reader {
    decoder: frcode::Decoder<BufReader<zstd::Decoder<File>>>,
}

impl Reader {
    /// Opens a nix-index database located at the given path.
    ///
    /// If the path does not exist or is not a valid database, an error is returned.
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Reader> {
        let mut file = File::open(path)?;
        let mut magic = [0u8; 4];
        file.read_exact(&mut magic)?;

        if magic != FILE_MAGIC {
            return Err(ErrorKind::UnsupportedFileType(magic.to_vec()).into());
        }

        let version = file.read_u64::<LittleEndian>()?;
        if version != FORMAT_VERSION {
            return Err(ErrorKind::UnsupportedVersion(version).into());
        }

        let decoder = zstd::Decoder::new(file)?;
        Ok(Reader { decoder: frcode::Decoder::new(BufReader::new(decoder)) })
    }

    /// Finds all entries in the database that have a filename matching the given pattern.
    ///
    /// Note: Since the reader consumes its input, you should probably only call this function once
    /// as the first call will consume the input thus any further calls will return no results.
    ///
    /// This returns an `Iterator` over the matches found. There is no guarantee about the order
    /// the matches are returned in.
    pub fn find_iter<'a, 'b>(&'a mut self, pattern: &'b Grep) -> ReaderIter<'a, 'b> {
        ReaderIter {
            reader: self,
            found: Vec::new(),
            found_without_package: Vec::new(),
            pattern: pattern,
            package_entry_pattern: GrepBuilder::new("^p\0").build().expect("valid regex"),
        }
    }

    /// Dumps the contents of the database to stdout, for debugging.
    #[cfg_attr(feature = "cargo-clippy", allow(print_stdout))]
    pub fn dump(&mut self) -> Result<()> {
        loop {
            let block = self.decoder.decode()?;
            if block.is_empty() { break }
            for line in block.split(|c| *c == b'\n') {
                println!("{:?}", String::from_utf8_lossy(line));
            }
            println!("-- block boundary");
        }
        Ok(())
    }
}

/// An iterator for entries in a database matching a given pattern.
pub struct ReaderIter<'a, 'b> {
    /// The underlying reader from which we read input.
    reader: &'a mut Reader,
    /// Entries that matched the pattern but have not been returned by `next` yet.
    found: Vec<(StorePath, FileTreeEntry)>,
    /// Entries that matched the pattern but for which we don't know yet what package they belong to.
    /// This may happen if the entry we matched was at the end of the search buffer, so that the entry
    /// for the package did not fit into the buffer anymore (since the package is stored after the entries
    /// of the package). In this case, we need to look for the package entry in the next iteration when
    /// we read the next block of input.
    found_without_package: Vec<FileTreeEntry>,
    /// The pattern for which to search package paths.
    pattern: &'b Grep,
    /// Pattern that matches only package entries.
    package_entry_pattern: Grep,
}

impl<'a, 'b> ReaderIter<'a, 'b> {
    /// Reads input until `self.found` contains at least one entry or the end of the input has been reached.
    fn fill_buf(&mut self) -> Result<()> {
        while self.found.is_empty() {
            let &mut ReaderIter {
                         ref mut reader,
                         ref package_entry_pattern,
                         ..
                     } = self;
            let block = reader.decoder.decode()?;

            if block.is_empty() {
                return Ok(());
            }

            let mut cached_package: Option<(StorePath, usize)> = None;
            let mut no_more_package = false;
            let mut find_package = |item_end| -> Result<_> {
                if let Some((ref pkg, end)) = cached_package {
                    if item_end < end {
                        return Ok(Some(pkg.clone()));
                    }
                }

                let mut mat = Match::new();
                if no_more_package || !package_entry_pattern.read_match(&mut mat, block, item_end) {
                    no_more_package = true;
                    return Ok(None);
                }

                let json = &block[mat.start() + 2..mat.end() - 1];
                let pkg: StorePath = serde_json::from_slice(json).chain_err(|| ErrorKind::StorePathParse(json.to_vec()))?;
                cached_package = Some((pkg.clone(), mat.end()));
                Ok(Some(pkg))
            };

            if !self.found_without_package.is_empty() {
                if let Some(pkg) = find_package(0)? {
                    for entry in self.found_without_package.split_off(0) {
                        self.found.push((pkg.clone(), entry));
                    }
                }
            }

            for mat in self.pattern.iter(block) {
                let entry = &block[mat.start()..mat.end() - 1];
                if self.package_entry_pattern.regex().is_match(entry) {
                    continue;
                }
                let entry = FileTreeEntry::decode(entry).ok_or_else(|| {
                    Error::from(ErrorKind::EntryParse(entry.to_vec()))
                })?;

                match find_package(mat.end())? {
                    None => self.found_without_package.push(entry),
                    Some(pkg) => self.found.push((pkg, entry)),
                }
            }
        }
        Ok(())
    }

    /// Returns the next match in the database.
    fn next_match(&mut self) -> Result<Option<(StorePath, FileTreeEntry)>> {
        self.fill_buf()?;
        Ok(self.found.pop())
    }
}

impl<'a, 'b> Iterator for ReaderIter<'a, 'b> {
    type Item = Result<(StorePath, FileTreeEntry)>;

    fn next(&mut self) -> Option<Self::Item> {
        match self.next_match() {
            Err(e) => Some(Err(e)),
            Ok(v) => v.map(Ok),
        }
    }
}
